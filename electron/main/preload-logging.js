'use strict';

// Custom preload wrapper.
// This file is NOT generated by expo-electron and is safe to edit.
// It loads the generated preload (ElectronNative bridge) and then forwards
// renderer console + uncaught errors to the main process.

// eslint-disable-next-line global-require
require('./preload.js');

// eslint-disable-next-line global-require
require('./preload-hardening.js');

const ENABLE_RENDERER_DIAGNOSTICS = (process.env.NODE_ENV !== 'production');

if (ENABLE_RENDERER_DIAGNOSTICS) {
    const { ipcRenderer } = require('electron');
    const { inspect } = require('util');

    function requireFunction(value, name) {
        if (typeof value !== 'function') throw new Error(`${name} must be a function`);
    }

    function requireObject(value, name) {
        if (!value || typeof value !== 'object') throw new Error(`${name} must be an object`);
    }

    function nowMs() {
        return Date.now();
    }

    function stringifyArgs(args) {
        const MAX_ARGS = 12;
        const list = Array.isArray(args) ? args.slice(0, MAX_ARGS) : [];
        const out = [];
        for (let i = 0; i < list.length; i++) {
            out.push(inspect(list[i], { depth: 3, maxArrayLength: 50, maxStringLength: 2000, breakLength: 120 }));
        }
        return out;
    }

    function sendConsole(level, args) {
        requireFunction(ipcRenderer.send, 'ipcRenderer.send');
        const payload = {
            level: String(level),
            ts: nowMs(),
            args: stringifyArgs(args),
        };
        ipcRenderer.send('renderer:console', payload);
    }

    function sendUncaught(kind, payload) {
        requireFunction(ipcRenderer.send, 'ipcRenderer.send');
        ipcRenderer.send('renderer:uncaught', {
            kind: String(kind),
            ts: nowMs(),
            payload,
        });
    }

    function installConsoleForwardingOrThrow() {
        requireObject(console, 'console');

        const levels = ['log', 'info', 'warn', 'error', 'debug'];
        for (let i = 0; i < levels.length; i++) {
            const lvl = levels[i];
            const orig = console[lvl];
            if (typeof orig !== 'function') continue;

            console[lvl] = function patchedConsole(...args) {
                sendConsole(lvl, args);
                return orig.apply(console, args);
            };
        }
    }

    function installUncaughtForwardingOrThrow() {
        if (typeof window !== 'object' || !window) throw new Error('window is required in preload to forward uncaught errors');

        window.addEventListener('error', (event) => {
            const err = event && event.error ? event.error : null;
            sendUncaught('error', {
                message: event && event.message ? String(event.message) : null,
                filename: event && event.filename ? String(event.filename) : null,
                lineno: event && typeof event.lineno === 'number' ? event.lineno : null,
                colno: event && typeof event.colno === 'number' ? event.colno : null,
                stack: err && err.stack ? String(err.stack) : null,
            });
        });

        window.addEventListener('unhandledrejection', (event) => {
            const reason = event ? event.reason : null;
            sendUncaught('unhandledrejection', {
                reason: inspect(reason, { depth: 4, maxArrayLength: 50, maxStringLength: 4000, breakLength: 120 }),
                stack: reason && reason.stack ? String(reason.stack) : null,
            });
        });
    }

    installConsoleForwardingOrThrow();
    installUncaughtForwardingOrThrow();
}
